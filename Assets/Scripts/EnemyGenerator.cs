using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using GGProductions.LetterStorm.Data;
using GGProductions.LetterStorm.Data.Collections;

/// <summary>
/// A FSM that spawns enemies or the boss depending on a number of criteria. The Enemy Generator keeps track of how many enemies are currently alive,
/// how many spawn points are available, whether or not the player has collected all letters necessary to defeat the boss and whether or not the player
/// has missed the boss with a letter required to win.
/// </summary>
public class EnemyGenerator : MonoBehaviour
{
    #region Public Variables ---------------------------------------------
    // Create the public variables that store data which can be accessed through the Unity editor

    public GameObject[] enemyPrefabs;
    public GameObject[] spawnPoints;
    public GameObject BossPrefab;
    public GameObject Boss1Prefab;
    public GameObject Boss2Prefab;


    public bool WordSolvingStage = false;  //hey Paul: this coul be a state ... I just needed a quick way to lett Albert know what stage it is
    //when albert kills the boss guns, the boss informs the enemy generator that it is now Word solving time
    // labert  checks what stage it is , and when it is word sloving time, he can start shoting letters

    #endregion Public Variables ---------------------------------------------

    #region Private Variables ---------------------------------------------
    
    /// <summary>
    /// The EnemyGenerator maintains an FSM. Depending on which state the machine is in, the spawning behaviors will change.
    /// This enum lists all possible states for the FSM. They are Idle, Initialize, Setup, SpawnEnemy, PrepBoss, and Boss.
    /// </summary>
    private enum State
    {
        Idle,
        Initialize,
        Setup,
        SpawnEnemy,
        PrepBoss,
        Boss
    }

    // A dictionary that maps the letters of the alphabet to their respective indices in the public enemyPrefabs array
    private Dictionary<char, int> LetterDict = new Dictionary<char, int>();

    private State state;
                     
    private int enemiesSpawned = 0;
    private bool bossSpawned = false;

    // This list contains each letter required to spell the boss word that the player has not yet collected
    private List<char> letterList;

    private char reqLetter;

    private GameObject[] bossArray=new GameObject[3];

    private int index;
    #endregion Private Variables ---------------------------------------------

    #region Event Handlers ---------------------------------------------
    /// <summary>
    /// As soon as possible, the FSM enters the initialization state.
    /// </summary>
    void Awake()
    {
        bossArray[0] = BossPrefab;
        bossArray[1] = Boss1Prefab;
        bossArray[2] = Boss2Prefab;

        index = Context.LevelNum % 3;

        state = State.Initialize;
    }
    /// <summary>
    /// The main game loop, continually checks the value of "state" in order to determine which corresponding method to execute.
    /// </summary>
    /// <returns>Returns zero.</returns>
    IEnumerator Start()
    {
        while (true)
        {
            switch (state)
            {
                case State.Initialize:
                    Initialize();
                    break;
                case State.Setup:
                    Setup();
                    break;
                case State.SpawnEnemy:
                    SpawnEnemy();
                    break;
                case State.Idle:
                    Idle();
                    break;
                case State.PrepBoss:
                    PrepBoss();
                    break;
                case State.Boss:
                    Boss();
                    break;
            }

            yield return 0;
        }
    }

    #endregion Event Handlers ---------------------------------------------

    #region Finite State Machine ---------------------------------------------
    
    /// <summary>
    /// This method is a one-time initialization that runs at the beginning of every level. First, there are two checks to make sure the array of enemy prefabs and spawnpoints are not empty.
    /// Next, each character in the word generated by the Context that the player must spell is added to the letterList. Each letter of the alphabet is a key to a corresponding integer in a dictionary
    /// so that the array of enemy prefabs may be accessed by letter. Finally, the FSM enters the Setup state.
    /// </summary>
    private void Initialize()
    {
        if (!CheckEnemyPrefabs())
        {
            return;
        }

        if (!CheckSpawnPoints())
        {
            return;
        }

        letterList = new List<char>(Context.Word.Text);

        for (int i = 0; i < Context.Alphabet.Length; i++)
        {
            LetterDict.Add(Char.ToLower(Context.Alphabet[i]), i);
        }

            state = State.Setup;
    }

    /// <summary>
    /// This method simply checks to see if the player has collected all required letters to spawn the boss. If so, the FSM enters the PrepBoss state. Otherwise, it enters
    /// the regular SpawnEnemy state. if the boss has already spawned, the FSM enters the Idle state.
    /// </summary>
    private void Setup()
    {
        if (letterList.Count < 1 && !bossSpawned)
        {
            state = State.PrepBoss;
        }
        else if (bossSpawned)
        {
            state = State.Idle;
        }
        else
        {
            state = State.SpawnEnemy;
        }
    }

    /// <summary>
    /// For each spawn point that does not have a living child, we may choose to either spawn an enemy or not.
    /// </summary>
    private void SpawnEnemy()
    {
        // Array of spawnpoints that have no children
        GameObject[] emptySpawns = AvailableSpawnPoints();
        
        // The number of enemies we will spawn, selected randomly
        int numOfEnemies = SpawnQuantity(emptySpawns.Length);

        SpawnEnemyHelper(emptySpawns, numOfEnemies);

        state = State.Setup;
    }

    /// <summary>
    /// This state is essentially a trap that waits for the player to defeat the boss and for the end of the level.
    /// </summary>
    private void Idle()
    {

    }

    /// <summary>
    /// The boss may only spawn if there are no living enemies on screen. If the conditions to reach this state have been met but there are living enemies, the FSM will continually call
    /// this method until all enemies are dead, at which point it may enter the Boss state.
    /// </summary>
    private void PrepBoss()
    {
        bool itLives = false;   // if any enemy is alive, itLives

        for (int i = 0; i < spawnPoints.Length; i++)
        {
            if (spawnPoints[i].transform.childCount > 0)
            {
                itLives = true;
            }
        }
        if (itLives)
        {
            state = State.Setup;
        }
        else
        {
            state = State.Boss;
        }
        
    }

    /// <summary>
    /// Depending on which level and difficulty has been selected, a certain boss prefab is instantiated and the FSM enters the Idle state.
    /// </summary>
    private void Boss()
    {

      //  GameObject go = Instantiate(Boss2Prefab,  new Vector3(0,0,2), Quaternion.Euler(180, 0, 180)) as GameObject;

        GameObject go = Instantiate(bossArray[index], new Vector3(0, 0, 2), Quaternion.Euler(180, 0, 180)) as GameObject;

      

        go.name = Boss2Prefab.name;

        bossSpawned = true;
        state = State.Idle;
    }

    #endregion Finite State Machine ---------------------------------------------

    #region Helper Methods ---------------------------------------------
    
    /// <summary>
    /// Ensure that at least one enemy prefab exists.
    /// </summary>
    /// <returns></returns>
    private bool CheckEnemyPrefabs()
    {
        if (enemyPrefabs.Length > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /// <summary>
    /// Ensure that at least one spawn point exists.
    /// </summary>
    /// <returns></returns>
    private bool CheckSpawnPoints()
    {
        if (spawnPoints.Length > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /// <summary>
    /// Genereate a list of spawn points that have no children.
    /// </summary>
    /// <returns>Returns the list of available spawn points as an array.</returns>
    private GameObject[] AvailableSpawnPoints()
    {
        List<GameObject> gos = new List<GameObject>();

        for (int i = 0; i < spawnPoints.Length; i++)
        {
            if (spawnPoints[i].transform.childCount == 0)
            {
                gos.Add(spawnPoints[i]);
            }
        }
        return gos.ToArray();
    }

    /// <summary>
    /// Determines a random number of enemies to spawn.
    /// </summary>
    /// <param name="splen">The number of available spawn points, an upper bound number of enemies that may be spawned.</param>
    /// <returns>Returns the number of enemies to spawn as an integer.</returns>
    private int SpawnQuantity(int splen)
    {
        int sq = UnityEngine.Random.Range(0, splen);

        if (Context.EnemyDifficulty.MaxEnemiesOnScreen < sq)
        {
            return Context.EnemyDifficulty.MaxEnemiesOnScreen;
        }
        else
        {
            return sq;
        }
    }

    /// <summary>
    /// Determines whether or not the enemy that is about to be spawned will contain a letter that the player needs or if it will be random.
    /// For each enemy spawned, there is a one in three chance that that enemy will contain a required letter.
    /// </summary>
    /// <param name="sps">The array of available spawn points.</param>
    /// <param name="sc">The number of enemies to spawn.</param>
    private void SpawnEnemyHelper(GameObject[] sps, int sc)
    {
        if (letterList.Count >= 1)
            reqLetter = letterList[UnityEngine.Random.Range(0, letterList.Count)];

        int enemyIndex = UnityEngine.Random.Range(0, enemyPrefabs.Length);

        for (int i = 0; i < sc; i++)
        {

            if (i == 0 && UnityEngine.Random.Range(0,2) > 0)
            {
                RequiredSpawn(sps, reqLetter, sc);
            }
            else
            {
                RandomSpawn(sps, enemyIndex, sc);
                sc= (sc+ 1) % sps.Length;
            }

            enemyIndex = UnityEngine.Random.Range(0, enemyPrefabs.Length);
            enemiesSpawned++;

        }
    }

    /// <summary>
    /// Spawns an enemy who contains a letter that the player needs in order to spell the boss word.
    /// </summary>
    /// <param name="sps">The array of available spawn points.</param>
    /// <param name="rl">The required letter to be spawned.</param>
    /// <param name="si">The index of the spawn point which will be the parent of the newly spawned enemy.</param>
    public void RequiredSpawn(GameObject[] sps, char rl, int si)
    {
         GameObject go = Instantiate(enemyPrefabs[LetterDict[rl]],
                               sps[si].transform.position, Quaternion.Euler(0, 0, 0)) as GameObject;

         go.name = enemyPrefabs[LetterDict[rl]].name;
         go.GetComponent<Enemy>().Speed = 2;
         go.transform.parent = sps[si].transform;

    }

    /// <summary>
    /// Spawns a random enemy who may or may not contain a letter that the player needs in order to spell the boss word.
    /// </summary>
    /// <param name="sps">The array of available spawn points.</param>
    /// <param name="ei">The index of the enemy to be spawned.</param>
    /// <param name="si">The index of the spawn point which will be the parent of the newly spawned enemy.</param>
    public void RandomSpawn(GameObject[] sps, int ei, int si)
    {
        GameObject go = Instantiate(enemyPrefabs[ei],
                               sps[si].transform.position, Quaternion.Euler(0, 0, 0)) as GameObject;

        go.name = enemyPrefabs[ei].name;
        go.GetComponent<Enemy>().Speed = 2;
        go.transform.parent = sps[si].transform;

    }

    /// <summary>
    /// Attaches a number of event listeners to methods so that the relevant message broadcasts from other scripts will call the respsective methods.
    /// </summary>
    public void OnEnable()
    {
        Messenger<char>.AddListener("letter projectile died", InventoryCheck);
        Messenger<string>.AddListener("picked up a letter", RequirementCheck);
        Messenger<string>.AddListener("slowing down time", Slow);
        Messenger.AddListener("vowel died", EnemyDead);
        Messenger.AddListener("cons died", EnemyDead);
    }

    /// <summary>
    /// Disables all event listeners.
    /// </summary>
    public void OnDisable()
    {
        Messenger<char>.RemoveListener("letter projectile died", InventoryCheck);
        Messenger<string>.RemoveListener("picked up a letter", RequirementCheck);
        Messenger<string>.RemoveListener("slowing down time", Slow);
        Messenger.RemoveListener("vowel died", EnemyDead);
        Messenger.RemoveListener("cons died", EnemyDead);
    }

    /// <summary>
    /// When an enemy broadcasts a message that it is about to die, this method decreases the living enemies count by one.
    /// </summary>
    public void EnemyDead()
    {
        enemiesSpawned--;
    }

    /// <summary>
    /// Reduces the speed of all enemies currently alive to 40% of their current speed.
    /// </summary>
    /// <param name="s">The message broadcast</param>
    public void Slow(string s) 
    {

        for (int i = 0; i < spawnPoints.Length; i++)
        {
            foreach (Transform t in spawnPoints[i].transform) {
                Enemy e = t.GetComponent<Enemy>();
                e.Speed *= 0.4f;
            }
        }

    }

    /// <summary>
    /// Checks the quantity of a certain letter the player has in his/her inventory after firing said letter. If not, a new one is provided.
    /// </summary>
    /// <param name="c">The letter projectile that was just destroyed.</param>
    public void InventoryCheck(char c)
    {
        if (Context.PlayerInventory.GetLetterCount(c.ToString()) < 1) {
            GameObject go = Instantiate(Resources.Load("LettesProjectile/" + c + "_projectilePrefab"),
                                            spawnPoints[3].transform.position, Quaternion.Euler(90, 0, 0)) as GameObject;

            go.AddComponent("CollectibleChar");
            go.tag = "letterPickup";
        }
    }

    /// <summary>
    /// If the letter that was just collected is in the list of letters that the player has not yet obtained, remove this letter from the list since the player just collected it.
    /// </summary>
    /// <param name="s">The letter that the player just collected.</param>
    public void RequirementCheck(string s)
    {
        if (letterList.Contains(s.ToLower()[0]))
        {
            letterList.Remove(s.ToLower()[0]);
        }
    }
    #endregion Helper Methods ---------------------------------------------
}
